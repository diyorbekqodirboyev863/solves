# Solves

1. **Binary Search:** Implement binary search to find an element in a sorted array.

2. **Factorial Calculation:** Compute the factorial of a number \( n \) iteratively and recursively.

3. **Fibonacci Sequence:** Generate the first \( n \) Fibonacci numbers using iterative and recursive methods.

4. **Prime Numbers:** Check if a number is prime and list all primes up to a given number.

5. **Greatest Common Divisor (GCD):** Find the GCD of two numbers using Euclid's algorithm.

6. **Least Common Multiple (LCM):** Compute the LCM of two integers using their GCD.

7. **Matrix Multiplication:** Multiply two matrices and handle dimension validation.

8. **Sorting Algorithms:** Implement and compare Bubble Sort, Merge Sort, and Quick Sort.

9. **Permutations:** Generate all permutations of a given string or array.

10. **Combinations:** Compute combinations \( C(n, k) \) using factorials and implement efficient algorithms.

11. **Linear Regression:** Perform linear regression on a dataset to find the best-fit line.

12. **N-Queens Problem:** Solve the N-Queens problem for placing \( N \) queens on an \( N \times N \) chessboard.

13. **Graph Traversal:** Implement BFS and DFS for graph traversal.

14. **Knapsack Problem:** Solve the 0/1 knapsack problem using dynamic programming.

15. **String Matching:** Implement the Knuth-Morris-Pratt (KMP) algorithm for substring search.

16. **Dijkstra's Algorithm:** Find the shortest path in a weighted graph using Dijkstra’s algorithm.

17. **Euler’s Totient Function:** Compute Euler’s totient function \( \phi(n) \).

18. **Powerset Generation:** Generate the powerset (all subsets) of a given set.

19. **Graph Coloring:** Implement a graph coloring algorithm to color a graph using the minimum number of colors.

20. **Sieve of Eratosthenes:** Find all prime numbers up to a given limit using the Sieve of Eratosthenes.

21. **Matrix Transposition:** Write a function to transpose a matrix.

22. **Longest Common Subsequence:** Implement an algorithm to find the longest common subsequence between two strings.

23. **Longest Increasing Subsequence:** Find the longest increasing subsequence in a given array.

24. **Convex Hull:** Implement the Gift Wrapping (Jarvis March) algorithm to find the convex hull of a set of points.

25. **Dynamic Programming - Fibonacci Sequence:** Optimize the Fibonacci sequence calculation using dynamic programming.

26. **Optimal Binary Search Tree:** Solve the problem of constructing an optimal binary search tree from a given frequency table.

27. **Topological Sorting:** Implement topological sorting for a directed acyclic graph (DAG).

28. **Matrix Chain Multiplication:** Determine the optimal way to multiply a given sequence of matrices.

29. **Kruskal’s Algorithm:** Find the minimum spanning tree of a graph using Kruskal’s algorithm.

30. **Prim’s Algorithm:** Find the minimum spanning tree of a graph using Prim’s algorithm.

31. **Backtracking - Sudoku Solver:** Implement a Sudoku solver using backtracking.

32. **Backtracking - Rat in a Maze:** Solve the problem of finding a path through a maze using backtracking.

33. **Counting Inversions:** Count the number of inversions in an array using merge sort.

34. **Merge Intervals:** Given a collection of intervals, merge overlapping intervals.

35. **Subarray Sum:** Find the maximum sum of any contiguous subarray (Kadane's Algorithm).

36. **Jump Game:** Determine if you can reach the last index of an array where each element represents the maximum jump length from that position.

37. **Edit Distance:** Compute the minimum number of operations required to convert one string into another (Levenshtein distance).

38. **Substring Search - Rabin-Karp:** Implement the Rabin-Karp algorithm for efficient substring searching.

39. **Maximum Flow - Ford-Fulkerson:** Implement the Ford-Fulkerson algorithm to find the maximum flow in a flow network.

40. **Minimum Edit Distance:** Calculate the minimum edit distance between two strings, considering insertion, deletion, and substitution.

41. **Heap Operations:** Implement heap operations such as insertion, deletion, and heapify for both min-heaps and max-heaps.

42. **Eulerian Path/Circuit:** Determine if a graph has an Eulerian path or circuit and find it if it exists.

43. **Hamiltonian Path/Circuit:** Implement a backtracking algorithm to find a Hamiltonian path or circuit in a graph.

44. **Bellman-Ford Algorithm:** Compute shortest paths from a single source to all vertices in a graph with possible negative weights.

45. **K-Means Clustering:** Implement the K-Means clustering algorithm for partitioning data into clusters.

46. **Gaussian Elimination:** Solve a system of linear equations using Gaussian elimination.

47. **Matrix Determinant:** Compute the determinant of a matrix using recursion or LU decomposition.

48. **Trie Data Structure:** Implement a trie (prefix tree) for efficient retrieval of words or prefixes.

49. **Rabin-Karp Algorithm:** Implement the Rabin-Karp algorithm for pattern matching in a text.

50. **Fast Fourier Transform (FFT):** Implement the Fast Fourier Transform for efficient polynomial multiplication.
